group by

데이터 베이스를 이용하면서 각 항목이나 그룹별로 데이터를 묶어야 할 필요가 있다.
이때 사용하는 데이터 베이스 명령어는 ```GROUP BY``` 명령어이다.
이는 ORACLE을 비롯한 다른 데이터 베이스에서 공통적으로 사용된다.

```sql
-- JOB_ID 를 기준으로 묶는다.
SELECT *
FROM EMPLOYEES
GROUP BY JOB_ID;


SELECT COUNT(*), SUM(SALARY), AVG(SALARY)
FROM EMPLOYEES
WHERE JOB_ID = 'IT_PROG';

/*
 NVL 함수
 NVL( 대상이 되는 컬럼, 숫자)
 대상이 되는 컬럼이 NULL이 아니면, 컬럼을 집어넣고
 아니면, 뒤의 숫자를 집어넣는다.

 NVL2 함수
 NVL2( 대상이 되는 컬럼, 숫자, 숫자)
 대상이 되는 컬럼이 NULL이 아니면, 첫번째 숫자를 집어넣고
 아니면, 두번째 숫자를 집어넣는다.
*/
SELECT EMPNO, NVL(MGR, 0) MGR
FROM EMP
WHERE DEPTNO = 10;

-- GROUP BY
-- HAVING 조건절
-- JOB_ID 로 묶인 잡의 월급 합계
SELECT JOB_ID, SUM(SALARY)
FROM EMPLOYEES
GROUP BY JOB_ID;

SELECT JOB_ID, SUM(SALARY)
FROM EMPLOYEES
GROUP BY JOB_ID
HAVING SUM(SALARY) >30000;

SELECT DEPARTMENT_ID, JOB_ID, COUNT(SALARY), SUM(SALARY), AVG(SALARY)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID, JOB_ID;

SELECT JOB_ID, COUNT(SALARY), SUM(SALARY), AVG(SALARY)
FROM EMPLOYEES
WHERE SALARY > 2000
GROUP BY JOB_ID
HAVING SUM(SALARY)>20000;

/*
그룹 함수와 연계해서 사용하는 것
COUNT(*) OVER(PARTITION BY
MAX
MIN
SUM


RANK()
ROW_NUMBER
DENSE_RANK
*/
SELECT SUM(SALARY), COUNT(*), JOB_ID
FROM EMPLOYEES
GROUP BY JOB_ID
ORDER BY JOB_ID;

SELECT FIRST_NAME, JOB_ID, SALARY,
    COUNT(JOB_ID) OVER(PARTITION BY JOB_ID),
    SUM (SALARY) OVER(PARTITION BY JOB_ID),
    SUM (SALARY) OVER(PARTITION BY DEPARTMENT_ID),
    DEPARTMENT_ID
FROM EMPLOYEES
ORDER BY JOB_ID;
```
